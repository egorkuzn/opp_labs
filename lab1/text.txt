0: gen(A)
scatter(count_of_parts)
+--------------------+
|0(A) -> 1(A_part)   |
|     |-> 2(A_part)  |
|     |-> 0(A_part)  |
+--------------------+

o:gen(b)
all: bcast(b)

all: x0 = 0;

xn=1 = xn - t(A * xn - b)

-------MULTIPLAYING_OF_MATRIX_ON_VECTOR-------

i : x1(0,1) = A_part(0,1) * x0;
i : x1(0,1) -= b(_, _ );
i : tau * x1(0,1) = x1(0,1);
i : x0(_,_) - x1(0, 1) = x1(0, 1);


gather() - for only one
0 process: | | | -> o: | | | | | | |
1 process: | | | --^ 
2 process: | | | --^

allgather() - for everybody
0 process: | | | -> 0,1,2: | | | | | | |
1 process: | | | --^ 
2 process: | | | --^

all : allgather(x1)
 ______________
V allreduce(+)

comments*: no use sqrt, norm(B) take only one time

A(N x N)
             b
* * * * * * |
* * * * * * |_
* * * * * * |
* * * * * * |_
* * * * * * |

all : scatter(A)
0 : gen(b)
all : scatter(b)
all : scatter(b)
all : gen(x0 (0,1))

for 0 process:
0 : x0(0) * / a00\  + x0(1) * / a10 \ = / w0  \
            | a10 |           | a11 |   | w1  |
            | ... |           | ... |   | ... |
            \ an0 /           \ an0 /   \ wn  /

allreduce --- 0: (w) + 1 : (w) + 2 : (w)

Построить графиики ускорения и эффективности:
есть большая программа. Эти вещи для любой проги. Ок - распараллели. Но получил ли я эффект?
Могу выирать на 5%, могу на 10%. А с параллельной прораммой просидел неделю, хотя получил выигрыш.
Смотрим эффективность относительно этих двух параметров.

Ускорение: Sp = T1 / Tp , где T1 - последовательная программа, а Tp - параллельная(MPI). Если MPI - то на одной машине будет хуже. Поэтому это не берём. И p в данном случае p = число ядер

Эфферктивность: Ep = Sp / p 

0 < Ep < 1, т.к. накладные раскоды, то T1 / Tp < p
Но на практике может быть переход на кэш нижний при последовательном. А при параллельной - оптимизировано

<<<<<<< HEAD
Посмотреть p = 2, 4, 8, 16, 24
=======
Посмотреть p = 2, 4, 8, 16, 24
>>>>>>> af1b601513f20eb7f6dd0e73aabf1a65dfe0a7da
